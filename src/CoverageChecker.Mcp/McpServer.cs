using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using CoverageChecker.Results;
using CoverageChecker.Services;
using Microsoft.Extensions.Logging;

namespace CoverageChecker.Mcp;

internal partial class McpServer(
    ILoggerFactory loggerFactory,
    IProcessExecutor? processExecutor = null,
    Func<IEnumerable<string>, IFileFinder>? fileFinderFactory = null)
{
    private readonly ILogger _logger = loggerFactory.CreateLogger<McpServer>();
    private readonly IProcessExecutor _processExecutor = processExecutor ?? new ProcessExecutor();
    private readonly Func<IEnumerable<string>, IFileFinder> _fileFinderFactory = fileFinderFactory ?? (patterns => new FileFinder(patterns));
    private readonly JsonSerializerOptions _jsonOptions = new() { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull };

    public async Task RunAsync(TextReader reader, TextWriter writer)
    {
        while (await reader.ReadLineAsync() is { } line)
        {
            try
            {
                var request = JsonSerializer.Deserialize<McpRequest>(line, _jsonOptions);
                if (request == null) continue;

                McpResponse response = await HandleRequest(request);
                string responseJson = JsonSerializer.Serialize(response, _jsonOptions);
                await writer.WriteLineAsync(responseJson);
                await writer.FlushAsync();
            }
            catch (Exception ex)
            {
                LogMcpRequestProcessingError(ex);
            }
        }
    }

    private async Task<McpResponse> HandleRequest(McpRequest request)
    {
        return request.Method switch
        {
            "initialize" => new McpResponse("2.0", request.Id, new { protocolVersion = "2024-11-05", capabilities = new { tools = new { } }, serverInfo = new { name = "coverage-checker", version = "1.0.0" } }),
            "tools/list" => new McpResponse("2.0", request.Id, ListTools()),
            "tools/call" => new McpResponse("2.0", request.Id, await CallTool(request.Params)),
            _ => new McpResponse("2.0", request.Id, Error: new McpError(-32601, $"Method not found: {request.Method}"))
        };
    }

    private McpToolListResponse ListTools()
    {
        return new McpToolListResponse(
        [
            new McpTool(
                "analyze_delta",
                "Analyzes coverage for changed lines (delta) compared to a base branch or commit.",
                new {
                    type = "object",
                    properties = new {
                        format = new { type = "string", @enum = new[] { "SonarQube", "Cobertura" }, description = "The coverage file format." },
                        directory = new { type = "string", description = "The directory to search for coverage files." },
                        globPatterns = new { type = "array", items = new { type = "string" }, description = "Glob patterns to find coverage files (e.g. ['**/*.xml'])" },
                        baseBranch = new { type = "string", description = "The base branch/commit to compare against (e.g. 'main')." }
                    },
                    required = new[] { "format", "directory", "globPatterns", "baseBranch" }
                }
            ),
            new McpTool(
                "get_coverage_summary",
                "Provides a high-level summary of the overall code coverage.",
                new {
                    type = "object",
                    properties = new {
                        format = new { type = "string", @enum = new[] { "SonarQube", "Cobertura" } },
                        directory = new { type = "string" },
                        globPatterns = new { type = "array", items = new { type = "string" } }
                    },
                    required = new[] { "format", "directory", "globPatterns" }
                }
            ),
            new McpTool(
                "run_tests_and_analyze",
                "Runs a test command and then performs delta coverage analysis on the resulting report.",
                new {
                    type = "object",
                    properties = new {
                        testCommand = new { type = "string", description = "The command to run tests (e.g., 'dotnet test --collect:\"XPlat Code Coverage\"')." },
                        format = new { type = "string", @enum = new[] { "SonarQube", "Cobertura" } },
                        directory = new { type = "string", description = "The root directory of the project." },
                        reportPath = new { type = "string", description = "The path or glob pattern to the coverage report generated by the test command." },
                        baseBranch = new { type = "string", description = "The base branch/commit for delta analysis. Default: 'main'." },
                        cleanup = new { type = "boolean", description = "Whether to delete the coverage reports after analysis. Default: false." }
                    },
                    required = new[] { "testCommand", "format", "directory", "reportPath" }
                }
            )
        ]);
    }

    private async Task<object> CallTool(object? paramsObj)
    {
        if (paramsObj == null) return new McpCallToolResponse([new McpContent("text", "Missing parameters")], true);
        
        var callRequest = JsonSerializer.Deserialize<McpCallToolRequest>(paramsObj.ToString()!, _jsonOptions);
        if (callRequest == null) return new McpCallToolResponse([new McpContent("text", "Invalid tool call request")], true);

        try
        {
            return callRequest.Name switch
            {
                "analyze_delta" => ExecuteAnalyzeDelta(callRequest.Arguments),
                "get_coverage_summary" => ExecuteGetSummary(callRequest.Arguments),
                "run_tests_and_analyze" => await ExecuteRunTestsAndAnalyze(callRequest.Arguments),
                _ => new McpCallToolResponse([new McpContent("text", $"Unknown tool: {callRequest.Name}")], true)
            };
        }
        catch (Exception ex)
        {
            return new McpCallToolResponse([new McpContent("text", $"Error executing tool: {ex.Message}")], true);
        }
    }

    private async Task<McpCallToolResponse> ExecuteRunTestsAndAnalyze(IDictionary<string, object>? args)
    {
        if (args == null) throw new ArgumentException("Arguments are required");

        string testCommand = args["testCommand"].ToString()!;
        string formatStr = args["format"].ToString()!;
        string directory = args["directory"].ToString()!;
        string reportPath = args["reportPath"].ToString()!;
        string baseBranch = args.TryGetValue("baseBranch", out var bb) ? bb.ToString()! : "main";
        bool cleanup = args.TryGetValue("cleanup", out var c) && c is JsonElement ce && ce.ValueKind == JsonValueKind.True;

        var format = Enum.Parse<CoverageFormat>(formatStr, true);

        // 1. Run Tests
        var (fileName, cmdArgs) = ParseCommand(testCommand);

        var (exitCode, stdout, stderr) = _processExecutor.Execute(fileName, cmdArgs, directory, TimeSpan.FromMinutes(5));

        var outputBuilder = new StringBuilder();
        outputBuilder.AppendLine($"Test Command Exited with code {exitCode}");
        if (!string.IsNullOrEmpty(stdout)) outputBuilder.AppendLine($"Stdout:\n{stdout}");
        if (!string.IsNullOrEmpty(stderr)) outputBuilder.AppendLine($"Stderr:\n{stderr}");

        try
        {
            // 2. Analyze Coverage
            var analyser = new CoverageAnalyser(format, directory, reportPath, loggerFactory);
            var delta = analyser.AnalyseDeltaCoverage(baseBranch);

            outputBuilder.AppendLine("\n--- Delta Coverage Analysis ---");
            if (!delta.HasChangedLines)
            {
                outputBuilder.AppendLine("No changed lines found in the current delta.");
            }
            else
            {
                var line = delta.Coverage.CalculateOverallCoverage();
                var branch = delta.Coverage.CalculateOverallCoverage(CoverageType.Branch);
                outputBuilder.AppendLine($"- Line Coverage: {line:P2}");
                outputBuilder.AppendLine($"- Branch Coverage: {branch:P2}");
                outputBuilder.AppendLine("\nMissing Lines in Delta:");
                outputBuilder.AppendLine(GetGaps(delta.Coverage));
            }
        }
        catch (Exception ex)
        {
            outputBuilder.AppendLine($"\n--- Delta Coverage Analysis Failed ---\n{ex.Message}");
        }
        finally
        {
            // 3. Optional Cleanup
            if (cleanup)
            {
                TryCleanupReports(directory, reportPath);
            }
        }

        return new McpCallToolResponse([new McpContent("text", outputBuilder.ToString())], exitCode != 0);
    }

    private McpCallToolResponse ExecuteAnalyzeDelta(IDictionary<string, object>? args)
    {
        var options = ParseArgs(args);
        var baseBranch = args?.TryGetValue("baseBranch", out var bb) == true ? bb.ToString()! : "main";

        var analyser = new CoverageAnalyser(options.Format, options.Directory, options.GlobPatterns, loggerFactory);
        var delta = analyser.AnalyseDeltaCoverage(baseBranch);

        if (!delta.HasChangedLines)
        {
            return new McpCallToolResponse([new McpContent("text", "No changed lines found in the current delta.")]);
        }

        var line = delta.Coverage.CalculateOverallCoverage();
        var branch = delta.Coverage.CalculateOverallCoverage(CoverageType.Branch);

        var report = $"Delta Coverage Results (Target: {baseBranch}):\n" +
                     $"- Line Coverage: {line:P2}\n" +
                     $"- Branch Coverage: {branch:P2}\n\n" +
                     "Missing Lines in Delta:\n" + GetGaps(delta.Coverage);

        return new McpCallToolResponse([new McpContent("text", report)]);
    }

    private McpCallToolResponse ExecuteGetSummary(IDictionary<string, object>? args)
    {
        var options = ParseArgs(args);
        var analyser = new CoverageAnalyser(options.Format, options.Directory, options.GlobPatterns, loggerFactory);
        var coverage = analyser.AnalyseCoverage();

        var line = coverage.CalculateOverallCoverage();
        var branch = coverage.CalculateOverallCoverage(CoverageType.Branch);

        var report = $"Overall Coverage Summary:\n" +
                     $"- Line Coverage: {line:P2}\n" +
                     $"- Branch Coverage: {branch:P2}\n" +
                     $"- Total Files: {coverage.Files.Count}";

        return new McpCallToolResponse([new McpContent("text", report)]);
    }

    private (CoverageFormat Format, string Directory, string[] GlobPatterns) ParseArgs(IDictionary<string, object>? args)
    {
        if (args == null) throw new ArgumentException("Arguments are required");

        string? formatStr = args["format"].ToString();
        var format = Enum.Parse<CoverageFormat>(formatStr!, true);
        string directory = args["directory"].ToString() ?? Environment.CurrentDirectory;
        
        List<string> globPatterns = [];
        if (args.TryGetValue("globPatterns", out var gp) && gp is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            foreach (var item in element.EnumerateArray())
            {
                globPatterns.Add(item.GetString()!);
            }
        }
        else
        {
            globPatterns.Add("*.xml");
        }

        return (format, directory, globPatterns.ToArray());
    }

    private void TryCleanupReports(string directory, string reportPath)
    {
        try
        {
            var finder = _fileFinderFactory([reportPath]);
            var filesToDelete = finder.FindFiles(directory).Where(File.Exists);
            foreach (var file in filesToDelete)
            {
                File.Delete(file);
            }
        }
        catch (Exception ex)
        {
            LogCleanupError(ex, reportPath);
        }
    }

    private static (string FileName, string[] Arguments) ParseCommand(string command)
    {
        var matches = Regex.Matches(command, @"[^\s""']+|""([^""]*)""|'([^']*)'");
        var parts = matches.Cast<Match>().Select(m => {
            if (m.Groups[1].Success) return m.Groups[1].Value;
            if (m.Groups[2].Success) return m.Groups[2].Value;
            return m.Value;
        }).ToArray();

        return (parts[0], parts.Skip(1).ToArray());
    }

    private static string GetGaps(Coverage coverage)
    {
        var sb = new StringBuilder();
        foreach (var file in coverage.Files)
        {
            var uncoveredLines = file.Lines.Where(l => !l.IsCovered).Select(l => l.LineNumber).ToList();
            if (uncoveredLines.Count > 0)
            {
                sb.AppendLine($"- {file.Path}: Lines {string.Join(", ", uncoveredLines)}");
            }
        }
        return sb.Length == 0 ? "No gaps found!" : sb.ToString();
    }

    [LoggerMessage(Level = LogLevel.Error, Message = "Error processing MCP request")]
    private partial void LogMcpRequestProcessingError(Exception ex);

    [LoggerMessage(Level = LogLevel.Warning, Message = "Failed to cleanup coverage reports matching {ReportPath}")]
    private partial void LogCleanupError(Exception ex, string reportPath);
}
